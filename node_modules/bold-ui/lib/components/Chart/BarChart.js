"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BarChart = void 0;
var react_1 = __importDefault(require("react"));
var recharts_1 = require("recharts");
var styles_1 = require("../../styles");
var adaptDomainToData_1 = require("./adaptDomainToData");
var convertSeries_1 = require("./convertSeries");
var getDomainPoints_1 = require("./getDomainPoints");
var renderAxis_1 = require("./renderAxis");
var renderSeries_1 = require("./renderSeries");
var renderTooltip_1 = require("./renderTooltip");
var util_1 = require("./util");
function BarChart(props) {
    var series = props.series, xAxis = props.xAxis, yAxis = props.yAxis, stacked = props.stacked, colorScheme = props.colorScheme, showLegend = props.showLegend, tooltip = props.tooltip, width = props.width, height = props.height;
    var theme = styles_1.useTheme();
    var domainPoints = getDomainPoints_1.getDomainPoints(yAxis.domain);
    var rangedSeries = adaptSeriesDataToRange(series, yAxis.domain, domainPoints);
    var adaptedXDomain = adaptDomainToData_1.adaptDomainToSeriesRange(xAxis === null || xAxis === void 0 ? void 0 : xAxis.domain, rangedSeries);
    var data = convertSeries_1.convertSeries(rangedSeries, domainPoints, null, null);
    return (react_1.default.createElement(recharts_1.ComposedChart, { data: data, width: width, height: height, margin: { top: 50, bottom: 0, left: 0, right: 30 }, layout: 'vertical', style: {
            fontFamily: theme.typography.fontFamily,
            fontSize: '0.8rem',
            color: theme.pallete.gray.c20,
        } },
        react_1.default.createElement(recharts_1.CartesianGrid, { vertical: true, horizontal: false }),
        react_1.default.createElement(recharts_1.Legend, { wrapperStyle: { padding: showLegend ? '2rem 2rem 1.5rem 3.5rem' : '1rem', fontSize: '0.8rem' }, content: showLegend ? undefined : function () { return false; }, align: 'left', iconSize: 11 }),
        renderAxis_1.renderAxis('y', yAxis, yAxis.domain, domainPoints, false, true),
        renderAxis_1.renderAxis('x', xAxis, adaptedXDomain, getDomainPoints_1.getDomainPoints(adaptedXDomain), false, true),
        series.map(function (s, i) {
            return renderSeries_1.renderBar(i, s, stacked, (tooltip === null || tooltip === void 0 ? void 0 : tooltip.type) === 'point', yAxis.domain, colorScheme !== null && colorScheme !== void 0 ? colorScheme : 'default', tooltip === null || tooltip === void 0 ? void 0 : tooltip.render);
        }),
        (tooltip === null || tooltip === void 0 ? void 0 : tooltip.type) === 'line' && renderTooltip_1.renderTooltip(xAxis, yAxis, tooltip === null || tooltip === void 0 ? void 0 : tooltip.render)));
}
exports.BarChart = BarChart;
var isNumberArray = function (array) { return typeof array[0] === 'number'; };
function adaptSeriesDataToRange(series, rangeDomain, rangeDomainPoints) {
    return series.map(function (_a) {
        var data = _a.data, rest = __rest(_a, ["data"]);
        return (__assign(__assign({}, rest), { data: isNumberArray(data)
                ? data.filter(function (_, i) { return i < rangeDomainPoints.length; })
                : data.filter(function (d) { return util_1.isInsideDomain(d.y, rangeDomain); }).map(function (d) { return ({ x: d.y, y: d.x }); }) }));
    });
}
BarChart.defaultProps = {
    tooltip: { type: 'point' },
    stacked: false,
    colorScheme: 'default',
    showLegend: true,
    height: 500,
};
//# sourceMappingURL=BarChart.js.map