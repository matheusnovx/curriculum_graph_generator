"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chart = void 0;
var react_1 = __importDefault(require("react"));
var recharts_1 = require("recharts");
var styles_1 = require("../../styles");
var colors_1 = require("../../styles/colors");
var adaptDomainToData_1 = require("./adaptDomainToData");
var convertReferenceRangesToPercents_1 = require("./convertReferenceRangesToPercents");
var convertSeries_1 = require("./convertSeries");
var getDomainPoints_1 = require("./getDomainPoints");
var model_1 = require("./model");
var RangeAreaTick_1 = require("./RangeAreaTick");
var renderAxis_1 = require("./renderAxis");
var renderSeries_1 = require("./renderSeries");
var renderTooltip_1 = require("./renderTooltip");
var util_1 = require("./util");
var getOutlierSeries_1 = require("./getOutlierSeries");
function Chart(props) {
    var type = props.type, series = props.series, xAxis = props.xAxis, yAxis = props.yAxis, referenceAreas = props.referenceAreas, stacked = props.stacked, colorScheme = props.colorScheme, showLegend = props.showLegend, tooltip = props.tooltip, rangeAreas = props.rangeAreas, width = props.width, height = props.height, _a = props.outliers, outliers = _a === void 0 ? 'expand-domain' : _a;
    var theme = styles_1.useTheme();
    var domainPoints = getDomainPoints_1.getDomainPoints(xAxis.domain);
    var _b = getOutlierSeries_1.splitOutlierSeries(series, xAxis.domain, domainPoints, yAxis === null || yAxis === void 0 ? void 0 : yAxis.domain, outliers), rangedSeries = _b.rangedSeries, outlierSeries = _b.outlierSeries, hasOutliers = _b.hasOutliers;
    var adaptedYDomain = adaptDomainToData_1.adaptDomainToSeriesRange(yAxis === null || yAxis === void 0 ? void 0 : yAxis.domain, rangedSeries, hasOutliers);
    var yDomainPoints = getDomainPoints_1.getDomainPoints(adaptedYDomain, hasOutliers);
    var referenceAreasWithPercents = convertReferenceRangesToPercents_1.convertReferenceRangesToPercents(referenceAreas, adaptedYDomain);
    var data = convertSeries_1.convertSeries(rangedSeries, domainPoints, adaptedYDomain, referenceAreasWithPercents, outlierSeries);
    return (react_1.default.createElement(recharts_1.ComposedChart, { data: data, width: width, height: height, margin: { top: 50, bottom: 0, left: 0, right: 30 }, layout: 'horizontal', style: {
            fontFamily: theme.typography.fontFamily,
            fontSize: '0.8rem',
            color: theme.pallete.gray.c20,
        } },
        react_1.default.createElement(recharts_1.CartesianGrid, { vertical: false, horizontal: true }),
        react_1.default.createElement(recharts_1.Legend, { wrapperStyle: { padding: showLegend ? '2rem 2rem 1.5rem 3.5rem' : '1rem', fontSize: '0.8rem' }, content: showLegend ? undefined : function () { return false; }, align: 'left', iconSize: 11 }),
        renderAxis_1.renderAxis('x', xAxis, xAxis.domain, domainPoints, false),
        renderAxis_1.renderAxis('y', yAxis, adaptedYDomain, yDomainPoints, hasOutliers),
        referenceAreas && renderAxis_1.renderReferenceAxis('y', referenceAreasWithPercents), referenceAreas === null || referenceAreas === void 0 ? void 0 :
        referenceAreas.map(function (ra, i) { return renderSeries_1.renderReferenceAreas(ra, i, colorScheme !== null && colorScheme !== void 0 ? colorScheme : 'default'); }), rangeAreas === null || rangeAreas === void 0 ? void 0 :
        rangeAreas.map(function (ra) {
            var _a, _b;
            return __spreadArrays([
                react_1.default.createElement(recharts_1.ReferenceArea, { yAxisId: 'data', x1: getRangeAreaInit(ra, xAxis.domain), x2: getRangeAreaEnd(ra, xAxis.domain), y1: util_1.getAxisDomainInit(adaptedYDomain), y2: util_1.getAxisDomainEnd(adaptedYDomain), stroke: 'none', fill: ((_a = ra.fillColor) !== null && _a !== void 0 ? _a : colors_1.blue.c60) || 'none', fillOpacity: (_b = ra.fillOpacity) !== null && _b !== void 0 ? _b : 0.2, label: react_1.default.createElement(RangeAreaTick_1.RangeAreaTick, { referenceArea: ra }) })
            ], (ra.strokeColor
                ? [
                    react_1.default.createElement(recharts_1.ReferenceLine, { yAxisId: 'data', stroke: ra.strokeColor, x: typeof ra.init === 'string' ? ra.init : +ra.init, position: 'start' }),
                    react_1.default.createElement(recharts_1.ReferenceLine, { yAxisId: 'data', stroke: ra.strokeColor, x: typeof ra.end === 'string' ? ra.end : +ra.end, position: 'start' }),
                ]
                : []));
        }),
        series.map(function (s, i) {
            return renderSeries_1.renderSeries(type, s, i, xAxis, stacked, colorScheme !== null && colorScheme !== void 0 ? colorScheme : 'default', (tooltip === null || tooltip === void 0 ? void 0 : tooltip.type) === 'point', s.name, tooltip === null || tooltip === void 0 ? void 0 : tooltip.render, data);
        }),
        (tooltip === null || tooltip === void 0 ? void 0 : tooltip.type) === 'line' && renderTooltip_1.renderTooltip(xAxis, yAxis, tooltip === null || tooltip === void 0 ? void 0 : tooltip.render)));
}
exports.Chart = Chart;
Chart.defaultProps = {
    type: model_1.SeriesType.Line,
    tooltip: { type: 'point' },
    stacked: false,
    colorScheme: 'default',
    showLegend: true,
    height: 500,
};
function getRangeAreaInit(ra, domain) {
    if (Array.isArray(domain))
        return domain.includes(ra.init) ? ra.init : domain[0];
    return Math.max(+ra.init, +domain.init);
}
function getRangeAreaEnd(ra, domain) {
    if (Array.isArray(domain))
        return domain.includes(ra.end) ? ra.end : domain[domain.length - 1];
    return Math.min(+ra.end, +domain.end);
}
//# sourceMappingURL=Chart.js.map