"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.adaptDomainToDataRange = exports.adaptDomainToSeriesRange = void 0;
var dateRangeStepToMillis_1 = require("./dateRangeStepToMillis");
var model_1 = require("./model");
var util_1 = require("./util");
var EXCEPTION_DOMAIN_MESSAGE = 'Domain init must be less than domain end';
function adaptDomainToSeriesRange(domain, series, hasOutlier) {
    var dataValues = series.flatMap(function (s) { return s.data.map(function (d) { return util_1.getDataPointValue(d); }); });
    return adaptDomainToDataRange(domain, dataValues, hasOutlier);
}
exports.adaptDomainToSeriesRange = adaptDomainToSeriesRange;
function adaptDomainToDataRange(domain, dataValues, hasOutlier) {
    if (!domain || !dataValues)
        return domain;
    if (Array.isArray(domain))
        return dataValues;
    var numericDataValues = dataValues.map(function (d) { return +d; }).filter(function (d) { return !isNaN(d); });
    if (!numericDataValues.length)
        return domain;
    if (model_1.isValueRange(domain))
        return adaptValueRangeDomainToData(domain, numericDataValues, hasOutlier);
    else
        return adaptDateRangeDomainToData(domain, numericDataValues, hasOutlier);
}
exports.adaptDomainToDataRange = adaptDomainToDataRange;
function adaptValueRangeDomainToData(domain, dataValues, hasOutlier) {
    if (domain.init >= domain.end)
        throw Error(EXCEPTION_DOMAIN_MESSAGE);
    var dataMin = Math.min.apply(Math, dataValues);
    var dataMax = Math.max.apply(Math, dataValues);
    return {
        init: dataMin < domain.init ? dataMin - (dataMin % domain.step) : domain.init,
        end: dataMax > domain.end && !hasOutlier ? dataMax + (domain.step - (dataMax % domain.step)) : domain.end,
        step: domain.step,
    };
}
function adaptDateRangeDomainToData(domain, dataValues, hasOutlier) {
    if (+domain.init >= +domain.end)
        throw Error(EXCEPTION_DOMAIN_MESSAGE);
    var valueDomain = adaptValueRangeDomainToData({
        init: +domain.init,
        end: +domain.end,
        step: dateRangeStepToMillis_1.dateRangeStepToMillis(domain.step),
    }, dataValues, hasOutlier);
    return {
        init: new Date(valueDomain.init),
        end: new Date(valueDomain.end),
        step: domain.step,
    };
}
//# sourceMappingURL=adaptDomainToData.js.map