"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSeries = void 0;
var createMonotoneCubicInterpolator_1 = __importDefault(require("./createMonotoneCubicInterpolator"));
var util_1 = require("./util");
function convertSeries(series, domainPoints, adaptedYDomain, refsAreas, outlierSeries) {
    var _a;
    var outlierTickValue = getOutlierTickValue(adaptedYDomain);
    var refs = (refsAreas !== null && refsAreas !== void 0 ? refsAreas : []).flatMap(function (refsAreas) {
        return refsAreas.areaPercents.map(function (data, i) {
            var _a;
            return _a = {
                    x: data.x
                },
                _a[refsAreas.label.name] = data.percent,
                _a;
        });
    });
    var data = (_a = (series !== null && series !== void 0 ? series : [])
        .flatMap(function (serie, serieIndex) {
        return serie.data.map(function (data, dataIndex) {
            var _a;
            var _b;
            var hasOutliers = outlierSeries && seriesHasOutliers(outlierSeries, serieIndex, dataIndex);
            return __assign({ x: (_b = data.x) !== null && _b !== void 0 ? _b : domainPoints[dataIndex] }, (hasOutliers
                ? getOutlierSeriesConfig(serie.name, data, outlierTickValue)
                : (_a = {}, _a[serie.name] = util_1.getDataPointValue(data), _a)));
        });
    })).concat.apply(_a, refs).sort(function (a, b) { return (a.x === b.x ? 0 : a.x > b.x ? 1 : -1); })
        .reduce(function (map, obj) {
        map.set(obj.x, __assign(__assign({}, map.get(obj.x)), obj));
        return map;
    }, new Map());
    /*
     * The values must be interpolated because Recharts considers empty values as 0
     * and the reference area crashes when there are X or Y points without a corresponding
     * reference area point.
     */
    var refValueNames = new Set(refs.flatMap(function (v) { return Object.keys(v); }));
    return interpolateValues(Array.from(data.values()), refValueNames);
}
exports.convertSeries = convertSeries;
var asNumber = function (x) { return (isNaN(+x) ? null : +x); };
function interpolateValues(orderedValues, valueNames) {
    valueNames.delete('x');
    var interpolators = getValuesInterpolators(orderedValues, valueNames);
    return orderedValues.map(function (v, i) {
        valueNames.forEach(function (vn) {
            var _a;
            if (!(vn in v))
                v[vn] = interpolators.get(vn)((_a = asNumber(v.x)) !== null && _a !== void 0 ? _a : i);
        });
        return v;
    });
}
function getValuesInterpolators(orderedValues, valueNames) {
    return Array.from(valueNames).reduce(function (interpolators, vn) {
        var valsWithVn = orderedValues.filter(function (v) { return vn in v; });
        var xs = valsWithVn.map(function (v, i) { var _a; return (_a = asNumber(v.x)) !== null && _a !== void 0 ? _a : i; });
        var ys = valsWithVn.map(function (v) { return v[vn]; });
        interpolators.set(vn, createMonotoneCubicInterpolator_1.default(xs, ys));
        return interpolators;
    }, new Map());
}
function getOutlierTickValue(adaptedYDomain) {
    var maxRange = util_1.getDomainMaxValue(adaptedYDomain);
    var outlierStep = util_1.getOutlierStepFromDomain(adaptedYDomain);
    var outlierTickValue = typeof maxRange === 'number'
        ? maxRange + outlierStep
        : maxRange instanceof Date
            ? new Date(maxRange.getTime() + outlierStep)
            : null;
    return outlierTickValue;
}
var seriesHasOutliers = function (outlierSeries, seriesIndex, dataIndex) { var _a; return !!((_a = outlierSeries[seriesIndex]) === null || _a === void 0 ? void 0 : _a.data[dataIndex]); };
var getOutlierSeriesConfig = function (seriesName, seriesData, outlierTickValue) {
    var _a;
    return _a = {},
        _a[seriesName] = outlierTickValue,
        _a[util_1.getOutlierSeriesName(seriesName)] = { value: util_1.getDataPointValue(seriesData), series: seriesName },
        _a;
};
//# sourceMappingURL=convertSeries.js.map