"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildTable = void 0;
var lodash_1 = require("lodash");
var GridArea_1 = require("../PivotTableCell/classes/GridArea");
var model_1 = require("../PivotTableCell/model");
var number_1 = require("../../../util/number");
var RESULT_PATH_KEY = 'RESULT';
var PATH_SEPARATOR = '|';
var TOTAL = 'Total';
var EMPTY = '-';
var IGNORED_TREE_KEYS = ['id', '__typename', 'nodeKey', 'nodeValue', 'maxLeafValue'];
function buildTable(rowKeys, columnKeys, defaultTree, complementaryTree, keysMapping) {
    if ((rowKeys === null || rowKeys === void 0 ? void 0 : rowKeys.length) && (complementaryTree === null || complementaryTree === void 0 ? void 0 : complementaryTree.nodeValue) !== undefined && (columnKeys === null || columnKeys === void 0 ? void 0 : columnKeys.length)) {
        return buildMixedTable(defaultTree, keysMapping, rowKeys, columnKeys, complementaryTree);
    }
    else if (rowKeys === null || rowKeys === void 0 ? void 0 : rowKeys.length) {
        return buildVerticalTable(defaultTree, keysMapping, rowKeys);
    }
    else if (columnKeys === null || columnKeys === void 0 ? void 0 : columnKeys.length) {
        return buildHorizontalTable(defaultTree, keysMapping, columnKeys);
    }
    return [];
}
exports.buildTable = buildTable;
function buildHorizontalTable(defaultTree, keysMapping, columnKeys) {
    var cellData = getListOfCellDataFromTree(defaultTree, 'row', keysMapping);
    var divs = getHorizontal({
        cellData: cellData,
        keys: columnKeys,
        tree: defaultTree,
        keysMapping: keysMapping,
    });
    return divs;
}
function buildVerticalTable(defaultTree, keysMapping, rowKeys) {
    var rowResult = getListOfCellDataFromTree(defaultTree, 'column', keysMapping);
    var divs = getVertical({
        cellData: rowResult,
        keys: rowKeys,
        tree: defaultTree,
        keysMapping: keysMapping,
        rowHeaderSpace: 2,
    }).divs;
    return divs;
}
function buildMixedTable(defaultTree, keysMapping, rowKeys, columnKeys, complementaryTree) {
    var rowResult = getListOfCellDataFromTree(defaultTree, 'column', keysMapping, rowKeys);
    var _a = getVertical({
        cellData: rowResult,
        keys: rowKeys,
        tree: defaultTree,
        keysMapping: keysMapping,
        rowHeaderSpace: columnKeys.length + 1,
        mixedTable: {
            totalKey: columnKeys[0],
        },
    }), horizontalDivs = _a.divs, rowTotalValues = _a.rowTotalValues, totalRowNumber = _a.totalRowNumber, cellPosition = _a.cellPositions;
    var columnResult = getListOfCellDataFromTree(complementaryTree, 'row', keysMapping, columnKeys);
    var verticalDivs = getHorizontal({
        cellData: columnResult,
        keys: columnKeys,
        tree: complementaryTree,
        keysMapping: keysMapping,
        columnHeaderSpace: rowKeys.length + 1,
        mixedTable: {
            rowResult: rowResult,
            rowTotalValues: rowTotalValues,
            totalKey: rowKeys[0],
            totalRowNumber: totalRowNumber,
            cellPositions: cellPosition,
        },
    });
    return horizontalDivs.concat(verticalDivs);
}
function getVertical(params) {
    var cellData = params.cellData, keys = params.keys, tree = params.tree, keysMapping = params.keysMapping, _a = params.rowHeaderSpace, rowHeaderSpace = _a === void 0 ? 1 : _a, mixedTable = params.mixedTable;
    var divs = [];
    var rowTotalValues = new Map();
    var cellPositions = [];
    var isMixedTable = !lodash_1.isNil(mixedTable);
    var tableHeaderDivs = buildVerticalTableHeader(keys, rowHeaderSpace, keysMapping);
    divs = divs.concat(tableHeaderDivs);
    var valuesAndKeys = buildVerticalValuesAndKeys(cellData, isMixedTable, mixedTable, rowTotalValues, keys, rowHeaderSpace);
    divs = divs.concat(valuesAndKeys.divs);
    cellPositions = cellPositions.concat(valuesAndKeys.cellPositions);
    var tableTotals = buildVerticalTableTotals(isMixedTable, valuesAndKeys.maxRowEnd, keys, rowHeaderSpace, valuesAndKeys.maxColumnEnd, tree.nodeValue);
    divs = divs.concat(tableTotals.divs);
    cellPositions = cellPositions.concat(tableTotals.cellPositions);
    return { divs: divs, rowTotalValues: rowTotalValues, totalRowNumber: valuesAndKeys.maxRowEnd, cellPositions: cellPositions };
}
function buildVerticalValuesAndKeys(cellData, isMixedTable, mixedTable, rowTotalValues, keys, rowHeaderSpace) {
    var divs = [];
    var cellPositions = [];
    var maxRowEnd = 0;
    var maxColumnEnd = 0;
    for (var _i = 0, cellData_1 = cellData; _i < cellData_1.length; _i++) {
        var cell = cellData_1[_i];
        if (isMixedTable) {
            if (cell.key === mixedTable.totalKey) {
                var rowTotalValuesKey = cell.path.replace(getCurrentPath(cell.key.toString(), cell.cellValue.toString()), '');
                rowTotalValues.set(rowTotalValuesKey, cell.total || 0);
            }
            if (!keys.includes(cell.key)) {
                continue;
            }
        }
        var lastKey = mixedTable && cell.key === keys[keys.length - 1];
        var value = cell.cellValue, span = cell.cellSpan, _a = cell.column, columnStart = _a === void 0 ? 0 : _a;
        var columnEnd = lastKey ? columnStart + 2 : columnStart + 1;
        var rowStart = getCellInitialPosition(cell.initialPosition) + rowHeaderSpace;
        var rowEnd = rowStart + span.value;
        maxRowEnd = lodash_1.max([rowEnd, maxRowEnd]);
        maxColumnEnd = columnEnd > maxColumnEnd ? columnStart : maxColumnEnd;
        var valuesGridArea = new GridArea_1.GridArea(rowStart, columnStart, rowEnd, columnEnd);
        var formattedValue = typeof value === 'number' ? number_1.formatDecimalOrInteger(value) : value;
        divs.push({
            gridArea: valuesGridArea,
            types: new Set(cell.key !== RESULT_PATH_KEY ? [model_1.PivotTableCellType.HEADER] : [model_1.PivotTableCellType.VALUE]),
            children: formattedValue,
            isEndColumn: cell.key === RESULT_PATH_KEY && !mixedTable,
        });
        cellPositions.push(valuesGridArea.toString());
    }
    return { maxRowEnd: maxRowEnd, maxColumnEnd: maxColumnEnd, divs: divs, cellPositions: cellPositions };
}
function getHorizontal(params) {
    var cellData = params.cellData, keys = params.keys, tree = params.tree, keysMapping = params.keysMapping, _a = params.columnHeaderSpace, columnHeaderSpace = _a === void 0 ? 1 : _a, mixedTable = params.mixedTable;
    var divs = [];
    var cellPositions = (mixedTable === null || mixedTable === void 0 ? void 0 : mixedTable.cellPositions) || [];
    var mixedTableStartRowCache = new Map();
    var mixedTableColumnTotals = new Map();
    var tableHeaderDivs = buildHorizontalTableHeader(keys, columnHeaderSpace, keysMapping);
    divs = divs.concat(tableHeaderDivs);
    var valuesAndKeys = buildHorizontalValuesAndKeys(cellData, columnHeaderSpace, mixedTable, mixedTableColumnTotals, keys, mixedTableStartRowCache);
    divs = divs.concat(valuesAndKeys.divs);
    cellPositions = cellPositions.concat(valuesAndKeys.cellPositions);
    if (mixedTable) {
        var tableTotals = buildMixedTableTotals(valuesAndKeys.maxColumnEnd, keys, mixedTable.rowTotalValues, mixedTableColumnTotals, mixedTable.totalRowNumber, mixedTableStartRowCache, columnHeaderSpace, tree.nodeValue, cellPositions);
        divs = divs.concat(tableTotals.divs);
    }
    else {
        var tableTotalsDivs = buildHorizontalTableTotals(valuesAndKeys.maxRowEnd, valuesAndKeys.maxColumnEnd, tree.nodeValue);
        divs = divs.concat(tableTotalsDivs);
    }
    return divs;
}
function buildHorizontalValuesAndKeys(cellData, columnHeaderSpace, mixedTable, mixedTableColumnTotals, keys, mixedTableStartRowCache) {
    var divs = [];
    var cellPositions = [];
    var maxRowEnd = 0;
    var maxColumnEnd = 0;
    var _loop_1 = function (cell) {
        var value = cell.cellValue;
        var columnSpan = cell.cellSpan;
        var rowStart = cell.row || 0;
        var columnStart = getCellInitialPosition(cell.initialPosition) + columnHeaderSpace;
        if (mixedTable) {
            if (cell.key === mixedTable.totalKey) {
                mixedTableColumnTotals.set(columnStart, cell.total || 0);
            }
            if (!keys.includes(cell.key) && cell.key !== RESULT_PATH_KEY) {
                return "continue";
            }
            if (mixedTable.rowResult && cell.key === RESULT_PATH_KEY) {
                var rows = mixedTable.rowResult.filter(function (rx) { return cell.path.indexOf(rx.path) !== -1; });
                rowStart = getCellInitialPosition(rows[rows.length - 1].initialPosition) + keys.length + 1;
                columnStart = getCellInitialPosition(cell.initialPosition.parentInitialPosition) + columnHeaderSpace;
                mixedTableStartRowCache.set(rows[rows.length - 1].path, rowStart);
            }
        }
        var lastKey = mixedTable && cell.key === keys[keys.length - 1];
        var rowEnd = lastKey ? rowStart + 2 : rowStart + 1;
        var columnEnd = columnStart + columnSpan.value;
        maxRowEnd = lodash_1.max([rowEnd, maxRowEnd]);
        maxColumnEnd = columnEnd > maxColumnEnd ? columnStart : maxColumnEnd;
        var gridArea = new GridArea_1.GridArea(rowStart, columnStart, rowEnd, columnEnd);
        if (cell.key === RESULT_PATH_KEY) {
            var formattedValue = typeof value === 'number' ? number_1.formatDecimalOrInteger(value) : value;
            divs.push({
                types: new Set([model_1.PivotTableCellType.VALUE]),
                gridArea: gridArea,
                children: formattedValue,
                isEndRow: mixedTable === undefined,
            });
        }
        else {
            divs.push({
                types: new Set([model_1.PivotTableCellType.HEADER]),
                gridArea: gridArea,
                children: value,
            });
        }
        cellPositions.push(gridArea.toString());
    };
    for (var _i = 0, cellData_2 = cellData; _i < cellData_2.length; _i++) {
        var cell = cellData_2[_i];
        _loop_1(cell);
    }
    return { maxRowEnd: maxRowEnd, maxColumnEnd: maxColumnEnd, divs: divs, cellPositions: cellPositions };
}
function buildVerticalTableHeader(keys, rowHeaderSpace, keysMapping) {
    var divs = [];
    keys.forEach(function (k, i) {
        var headerGridArea = new GridArea_1.GridArea(rowHeaderSpace, i + 1, rowHeaderSpace + 1, i + 2);
        divs.push({
            types: new Set([model_1.PivotTableCellType.HEADER]),
            gridArea: headerGridArea,
            children: keysMapping.get(k).keyName,
        });
    });
    return divs;
}
function buildHorizontalTableHeader(keys, columnHeaderSpace, keysMapping) {
    var divs = [];
    keys.forEach(function (k, i) {
        var headerGridArea = new GridArea_1.GridArea(i + 1, columnHeaderSpace, i + 2, columnHeaderSpace + 1);
        divs.push({
            types: new Set([model_1.PivotTableCellType.HEADER]),
            gridArea: headerGridArea,
            children: keysMapping.get(k).keyName,
        });
    });
    return divs;
}
function buildMixedTableTotals(maxColumnEnd, keys, mixedTableRowTotals, mixedTableColumnTotals, totalRowNumber, mixedTableStartRowCache, columnHeaderSpace, grandtotal, cellPositions) {
    var divs = [];
    var totalsGridArea = new GridArea_1.GridArea(1, maxColumnEnd + 1, keys.length + 2, maxColumnEnd + 2);
    var dataValueGridArea = new GridArea_1.GridArea(totalRowNumber, maxColumnEnd + 1, totalRowNumber + 1, maxColumnEnd + 2);
    var columnTotals = buildMixedTableColumnTotals(totalRowNumber, mixedTableColumnTotals);
    var rowTotals = buildMixedTableRowTotals(mixedTableStartRowCache, maxColumnEnd, mixedTableRowTotals);
    divs = divs.concat(columnTotals.divs, rowTotals.divs);
    cellPositions = cellPositions.concat(columnTotals.cellPositions);
    cellPositions = cellPositions.concat(rowTotals.cellPositions);
    var gridArea = new GridArea_1.GridArea(keys.length + 1, columnHeaderSpace, keys.length + 2, columnHeaderSpace + 1);
    divs.push({
        types: new Set([model_1.PivotTableCellType.HEADER]),
        gridArea: gridArea,
    });
    divs.push({
        types: new Set([model_1.PivotTableCellType.HEADER]),
        isEndColumn: true,
        gridArea: totalsGridArea,
        children: TOTAL,
    });
    divs.push({
        types: new Set([model_1.PivotTableCellType.TOTAL, model_1.PivotTableCellType.VALUE, model_1.PivotTableCellType.GRANDTOTAL]),
        isEndColumn: true,
        isEndRow: true,
        gridArea: dataValueGridArea,
        children: grandtotal,
    });
    cellPositions.push(dataValueGridArea.toString());
    for (var column = columnHeaderSpace + 1; column < maxColumnEnd + 2; column++) {
        for (var row = keys.length + 2; row < totalRowNumber + 1; row++) {
            var gridArea_1 = new GridArea_1.GridArea(row, column, row + 1, column + 1);
            if (!cellPositions.includes(gridArea_1.toString())) {
                divs.push({
                    types: new Set([model_1.PivotTableCellType.EMPTY]),
                    isEndColumn: column === maxColumnEnd + 1,
                    isEndRow: row === totalRowNumber,
                    gridArea: gridArea_1,
                    children: EMPTY,
                });
            }
        }
    }
    return { divs: divs };
}
function buildHorizontalTableTotals(maxRowEnd, maxColumnEnd, grandTotal) {
    var divs = [];
    var totalsGridArea = new GridArea_1.GridArea(maxRowEnd - 1, 1, maxRowEnd, 2);
    var dataValueGridArea = new GridArea_1.GridArea(maxRowEnd - 1, maxColumnEnd + 1, maxRowEnd, maxColumnEnd + 2);
    var totalGridArea = new GridArea_1.GridArea(1, maxColumnEnd + 1, maxRowEnd - 1, maxColumnEnd + 2);
    divs.push({
        types: new Set([model_1.PivotTableCellType.HEADER]),
        isEndColumn: true,
        gridArea: totalGridArea,
        children: TOTAL,
    });
    divs.push({
        types: new Set([model_1.PivotTableCellType.HEADER]),
        isEndRow: true,
        gridArea: totalsGridArea,
        children: TOTAL,
    });
    divs.push({
        types: new Set([model_1.PivotTableCellType.TOTAL, model_1.PivotTableCellType.VALUE, model_1.PivotTableCellType.GRANDTOTAL]),
        isEndRow: true,
        isEndColumn: true,
        gridArea: dataValueGridArea,
        children: grandTotal,
    });
    return divs;
}
function buildMixedTableColumnTotals(totalRowNumber, mixedTableColumnTotals) {
    var divs = [];
    var cellPositions = [];
    mixedTableColumnTotals.forEach(function (value, key) {
        var gridArea = new GridArea_1.GridArea(totalRowNumber, key, totalRowNumber + 1, key + 1);
        divs.push({
            types: new Set([model_1.PivotTableCellType.TOTAL, model_1.PivotTableCellType.VALUE]),
            isEndRow: true,
            gridArea: gridArea,
            children: value,
        });
        cellPositions.push(gridArea.toString());
    });
    return { divs: divs, cellPositions: cellPositions };
}
function buildMixedTableRowTotals(mixedTableStartRowCache, maxColumnEnd, mixedTableRowTotals) {
    var divs = [];
    var cellPositions = [];
    mixedTableRowTotals.forEach(function (value, key) {
        var rowNumber = mixedTableStartRowCache.get(key);
        if (rowNumber) {
            var gridArea = new GridArea_1.GridArea(rowNumber, maxColumnEnd + 1, rowNumber + 1, maxColumnEnd + 2);
            divs.push({
                types: new Set([model_1.PivotTableCellType.TOTAL, model_1.PivotTableCellType.VALUE]),
                isEndColumn: true,
                gridArea: gridArea,
                children: value,
            });
            cellPositions.push(gridArea.toString());
        }
    });
    return { divs: divs, cellPositions: cellPositions };
}
function buildVerticalTableTotals(isMixedTable, maxRowEnd, keys, rowHeaderSpace, maxColumnEnd, grandtotal) {
    var divs = [];
    var cellPositions = [];
    var totalsGridArea;
    if (isMixedTable) {
        totalsGridArea = new GridArea_1.GridArea(maxRowEnd, 1, maxRowEnd + 1, keys.length + 2);
    }
    else {
        totalsGridArea = new GridArea_1.GridArea(rowHeaderSpace, maxColumnEnd, rowHeaderSpace + 1, maxColumnEnd + 1);
        var totalGridArea = new GridArea_1.GridArea(maxRowEnd, 1, maxRowEnd + 1, maxColumnEnd);
        var dataValueGridArea = new GridArea_1.GridArea(maxRowEnd, maxColumnEnd, maxRowEnd + 1, maxColumnEnd + 1);
        divs.push({
            types: new Set([model_1.PivotTableCellType.HEADER]),
            isEndRow: true,
            gridArea: totalGridArea,
            children: TOTAL,
        });
        divs.push({
            types: new Set([model_1.PivotTableCellType.TOTAL, model_1.PivotTableCellType.GRANDTOTAL, model_1.PivotTableCellType.VALUE]),
            isEndRow: true,
            isEndColumn: true,
            gridArea: dataValueGridArea,
            children: grandtotal,
        });
    }
    divs.push({
        types: new Set([model_1.PivotTableCellType.HEADER]),
        isEndRow: isMixedTable,
        isEndColumn: !isMixedTable,
        gridArea: totalsGridArea,
        children: TOTAL,
    });
    cellPositions.push(totalsGridArea.toString());
    return { divs: divs, cellPositions: cellPositions };
}
function getCurrentPath(filterKey, value) {
    return PATH_SEPARATOR + filterKey + '.' + value;
}
/**
 * Sums the span values of the parent cells to find the starting coordinates of the current cell.
 */
function getCellInitialPosition(initialPositionTree) {
    var stack = [];
    var sum = 1;
    if (initialPositionTree) {
        stack.push(initialPositionTree);
    }
    else {
        return 0;
    }
    // Loop through the stack to calculate the sum of cellSpans
    while (stack.length) {
        var cell = stack.pop();
        if (cell.cellSpan) {
            sum += cell.cellSpan.value;
        }
        // Add children to the stack
        if (cell.auxInitialPosition) {
            stack.push(cell.auxInitialPosition);
        }
        else if (cell.parentInitialPosition) {
            stack.push(cell.parentInitialPosition);
        }
    }
    return sum;
}
function getListOfCellDataFromTree(tree, increment, keyMapping, onlyIncreaseSpanOnKeys) {
    var _a;
    var _b;
    var stack = [];
    var cellList = [];
    // Initialize the stack with the first node of the tree
    stack.push((_a = { treeNode: tree }, _a[increment] = 1, _a));
    var _loop_2 = function () {
        var obj = stack.shift();
        if (obj) {
            var lastCellSpan_1;
            var lastInitialValue_1;
            var currentNodeKey_1 = obj.treeNode.nodeKey;
            var shouldIncreaseCellSpan_1 = !onlyIncreaseSpanOnKeys || onlyIncreaseSpanOnKeys.includes(currentNodeKey_1);
            // loop through children nodes
            Object.keys(obj.treeNode)
                .filter(function (k) { return !IGNORED_TREE_KEYS.includes(k); })
                .sort((_b = keyMapping.get(currentNodeKey_1)) === null || _b === void 0 ? void 0 : _b.ordenator)
                .forEach(function (key) {
                var _a, _b, _c;
                var _d, _e, _f;
                // cellSpan: size of a cell
                var cellSpan = { value: 1 };
                // cellSpanList: list of current + previous cellSpans. To be used on the next loop cycle
                var cellSpanList = [cellSpan];
                if (obj.spanList) {
                    var myKeys = Object.keys(obj.treeNode).filter(function (k) { return !IGNORED_TREE_KEYS.includes(k); });
                    var lastSpan = obj.spanList[0];
                    if (myKeys.length > lastSpan.value && shouldIncreaseCellSpan_1) {
                        for (var i = 0; i < obj.spanList.length; i++) {
                            /**
                             * This increment might cause side effects on all existing SpanValue objects,
                             * including the ones inside CellInitialPosition objects. It is intentional
                             */
                            obj.spanList[i].value++;
                        }
                    }
                    cellSpanList.push.apply(cellSpanList, obj.spanList);
                }
                var rowOrColumn = obj[increment] || 0;
                var parentIni = obj.parentIni;
                var value = (_f = (_e = (_d = keyMapping.get(currentNodeKey_1)) === null || _d === void 0 ? void 0 : _d.formatter) === null || _e === void 0 ? void 0 : _e.call(_d, key)) !== null && _f !== void 0 ? _f : key;
                var currentPath = getCurrentPath(currentNodeKey_1, value);
                var path = obj.path ? obj.path + currentPath : currentPath;
                var initialPosition = {
                    parentInitialPosition: parentIni,
                    cellSpan: shouldIncreaseCellSpan_1 ? lastCellSpan_1 : { value: 0 },
                    auxInitialPosition: lastInitialValue_1,
                };
                // Push a key cell to the result list
                cellList.push((_a = {
                        cellSpan: cellSpan,
                        cellValue: value,
                        initialPosition: initialPosition
                    },
                    _a[increment] = rowOrColumn,
                    _a.path = path,
                    _a.key = obj.treeNode.nodeKey,
                    _a.total = obj.treeNode.nodeValue,
                    _a));
                if (obj.treeNode[key].nodeKey === undefined) {
                    // If it's a leaf node, push a value cell to the result list
                    cellList.push((_b = {
                            cellSpan: cellSpan
                        },
                        _b[increment] = rowOrColumn + 1,
                        _b.initialPosition = initialPosition,
                        _b.path = path + PATH_SEPARATOR + RESULT_PATH_KEY,
                        _b.cellValue = obj.treeNode[key].nodeValue,
                        _b.key = RESULT_PATH_KEY,
                        _b));
                }
                else {
                    // If it isn't a leaf node, add itself to the stack
                    stack.push((_c = {
                            treeNode: obj.treeNode[key],
                            spanList: cellSpanList
                        },
                        _c[increment] = rowOrColumn + 1,
                        _c.parentIni = initialPosition,
                        _c.path = path,
                        _c));
                }
                lastInitialValue_1 = initialPosition;
                lastCellSpan_1 = cellSpan;
            });
        }
    };
    // loop through the stack
    while (stack.length) {
        _loop_2();
    }
    return cellList;
}
//# sourceMappingURL=buildTable.js.map